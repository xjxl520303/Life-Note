## Obsidian Example Valut 案例集精选

[Dataview Example Vault (s-blu.github.io)](https://s-blu.github.io/obsidian_dataview_example_vault/) 提供了丰富的 Dataview 使用案例。通过这个示例仓库，用户可以学习到很多关于 Dataview 的知识，将其应用到自己的 Obsidian 工作流程中。这是一个很好的起点，但是由于其内容较多，需要花费大量时间和精力去实操，这是一个必然的过程，但是这个路不必自己去亲自走一遍，因为我已经为读者开辟了道路。

这一节我们将对其进行介绍，并挑选一部分具有代表性的典型案例来讲解，让读者感受其强大之处，并借鉴到自己的工作流程当中。

### 计算连续头痛的周期和持续时间

> 位置：20 Dataview Queries/Calculate cycle lengths and durations

通过 YAML 中的属性 `wellbeing.pain-type` 是否包含 `head` 来判断当日是否有头痛记录，然后计算持续的天数以及上一次的间隔周期。

````
```dataviewjs
const dt = dv.luxon.DateTime
const dur = dv.luxon.Duration

// 返回一个由每个页面的前一天的页面（如果存在）组成的集合，并按日期降序排序。需要注意的是，并不是所有日期都有前一天的数据。
let startDates = dv.pages('"10 Example Data/dailys"')
    .mutate(p => p.previousDay = dv.page(dt.fromMillis(p.file.day - dv.duration("1d"))
        .toFormat('yyyy-MM-dd')))
        .sort(p => p.file.name)

// 结束日期的数据：当日没有记录数据，但前一天有记录。
const endDates = dv.array(dv.clone(startDates)[0]).where(p => !checkCriteria(p) && checkCriteria(p.previousDay))

// 开始日期的数据：当日有记录数据，但前一天无记录。
startDates = startDates.where(p => checkCriteria(p) && !checkCriteria(p.previousDay))

// 存放周期数据
const cycles = []

for (let i = 0; i < endDates.length; i++) {
    cycles.push([
        startDates[i].file.link,
        endDates[i].file.link,
        dur.fromMillis(endDates[i].file.day - startDates[i].file.day),
        i === 0 ? '' : dur.fromMillis(startDates[i].file.day - endDates[i-1]?.file.day),
        i === 0 ? '' : dur.fromMillis(startDates[i].file.day - startDates[i-1]?.file.day).toFormat("d '天'")
    ])
}

// 输出为表格
dv.table(["开始", "结束", "持续时间", "间隔", "间隔周期"], cycles)

function checkCriteria(p) {
    return p && p.wellbeing && (p.wellbeing["pain-type"] || []).contains("head")
}
```
````

结果：

![[Pasted image 20240511181827.png]]

### 根据复选框动态显示内容

>位置：20 Dataview Queries/Display or hide dataview queries based on a task selection

当前页面中以作者名为任务名，当任务完成时自动去查询在日记中有引用自该作者的语录，当取消完成时，自动移除相关语录信息。

````
- [x] Michel Foucault
- [ ] Walter Benjamin
- [ ] Karl Marx

```dataviewjs
const checklist = dv.current().file.tasks.where(t => t.completed)
const authors = ["Michel Foucault", "Walter Benjamin", "Karl Marx"]

// 这里将原来代码中的 3 段代码用一个遍历重写了
authors.forEach(author => {
    if (isActive(author)) {
        dv.header(2, `${author} quotes`)
        dv.list(dv.pages('"10 Example Data/dailys"').flatMap(p => p.file.lists)
            .where(l => l.author == author)
            .text)
    }
})

function isActive(name) {
// 原代码使用 `t.text == name` 来判断并不准确
// 因为我们安装了 tasks 插件后，任务完成会自动加上表情符号和完成日期。
    return checklist.where(t => t.text.contains(name))[0]
}
```
````

结果：

![[Pasted image 20240511193408.png]]

### 按照文件中的顺序对重复的元数据字段进行分组

>位置：20 Dataview Queries/# Group duplicated meta data fields after their order in file

这个案例对日记中以下数据中的 `bought` 进行查询并显示出对应的 `paid` 数据。

````
#### Money spent

bought:: piece of cake
paid:: 7.99$

bought:: buddha bowl
paid:: 8.5$

bought:: jacket
paid:: 99$
````

从数据可以看出 `bought` 和 `paid` 在页面中是重复出现，这在 Obsidian 中将会被解析成 `bought: ['piece of cake', 'buddha bowl', 'jacket']` 和 `paid: ['7.99$', '8.5$', '99$']`。

下面是查询代码：

````
```dataviewjs
const pages = dv.pages('"10 Example Data/dailys"').where(p => p.bought)

const groupedValues = [];
for (let page of pages) {
    const length = Array.isArray(page.bought) ? page.bought.length : 1;
    for (let i = 0; i < length; i++) {
        groupedValues.push([
            page.file.link,
            getValue(page, 'bought', i),
            getValue(page, 'paid', i),
        ]);
    }
}

dv.table(["页面", "购买", "支付"], groupedValues)

function getValue(page, key, i) {
    return page[key] && Array.isArray(page[key]) ? page[key][i] : page[key];
}
```
````

结果：

![[Pasted image 20240512233848.png]]

从上面的结果来看，物品有一部分是经常购买的，比如说： `piece of cake`，现在我有一个想法浮现在脑海，我们能不能进一步根据 `bought` 的具体值再进行一次分组呢，相同组的名字以 `--` 显示，下面是期望得到的效果：

![[Pasted image 20240512235407.png]]

然后，我进入了无休止的尝试中...

最终，我实现出了想要的结果，但是这个代码有点长，不太好理解，也并不优雅：

````
```dataviewjs
const pages = dv.pages('"10 Example Data/dailys"').where(p => p.bought)
   .sort(p => p.file.name)

const groupedValues = [];
for (let page of pages) {
    const length = Array.isArray(page.bought) ? page.bought.length : 1;
    for (let i = 0; i < length; i++) {
        groupedValues.push([
            page.file.link,
            getValue(page, 'bought', i),
            getValue(page, 'paid', i),
        ]);
    }
}

// 重组数据
const newPages = groupedValues.map(g => {
    return {
        link: g[0],
        bought: g[1],
        paid: g[2],
    }
})

// 按 bought 进行分组
const newGroupedValues = dv.array(newPages)
    .groupBy(p => p.bought)
    .flatMap(g => g.rows)

dv.table(
    ["购买", "支付", "页面"],
    newGroupedValues.flatMap((g, i, arr) => {
        let j = 0; // 用于判断 bought 是否连续

        // 找到连续的 bought
        if (i > 0 && g.bought !== arr[i - 1].bought) {
            j = i;
        }

        // 计算连续的数量
        while (j < arr.length - 1 && arr[j+1].bought === g.bought) {
            j++;
        }

        if (j > i) {
            return Array(j - i + 1).fill(0).map((_, k) => {
                if (k === 0) {
                    return [g.bought, g.paid, g.link]
                } else {
                    // 相同名字显示 --
                    return ['--', arr[i + k].paid, arr[i + k].link]
                }
            })
        }

        // 单个 bought
        if (i === j && g.bought !== arr[i - 1].bought) {
            return [[g.bought, g.paid, g.link]]
        }
    })
)

function getValue(page, key, i) {
    return page[key] && Array.isArray(page[key]) ? page[key][i] : page[key];
}
```
````

上述代码是在 `groupedValues` 的基础上对数据进行了一次重映射，然后使用 `dv.array()` 方法将普通的 JavaScript 数组转换成 `DataArray<T>` 类型，然后使用其 `groupBy()` 方法按 `bought` 字段进行分组，然后使用 `flatMap()` 映射返回 `rows` 的值。

> [Tips] 使用 `groupBy()` 分组后返回一个包含 `key` 和 `rows` 的对象，其中 `key` 为分组名称，`rows` 是分组后的数据。

`flatMap()` 方法是一个很重要的函数，关于其用法可自行去脑补，后面处理分组数据部分写出来后，思索着应该还有更简单的实现。与是，作者又双叒叕熬夜想了想，终于以 2 个 `flatMap()` 方法成功破局，一行代码暴击（不追求代码可读性为前提）：

````
```dataviewjs
const pages = dv.pages('"10 Example Data/dailys"').where(p => p.bought)
   .sort(p => p.file.name)

const groupedValues = [];
for (let page of pages) {
    const length = Array.isArray(page.bought) ? page.bought.length : 1;
    for (let i = 0; i < length; i++) {
        groupedValues.push([
            page.file.link,
            getValue(page, 'bought', i),
            getValue(page, 'paid', i),
        ]);
    }
}

// 重组数据
const newPages = groupedValues.map(g => {
    return {
        link: g[0],
        bought: g[1],
        paid: g[2],
    }
})

// 按 bought 进行分组
const newGroupedValues = dv.array(newPages)
    .groupBy(p => p.bought)

dv.table(
   ["购买", "支付", "页面"],
   newGroupedValues.flatMap((g, i, arr) => 
        g.rows.flatMap((r, i, arr) => {
            if (i === 0) {
                return [[g.key, r.paid, r.link]]
            } else {
                return [['--', r.paid, r.link]]
            }
        })
   )
)

function getValue(page, key, i) {
    return page[key] && Array.isArray(page[key]) ? page[key][i] : page[key];
}
```
````

最后，如果你脑子又一转，在数据很多的情况下，是否可以将每个分组拆解出来单独显示呢？也就是说多个表格单独显示，像下面这样：

![[Pasted image 20240513001831.png]]

这必需安排起，只需要将上面的示例中的 `dv.table()` 部分改成下面的代码即可：

```js
for (let g of newGroupedValues) {
    dv.span('- ' + g.key)
    dv.table(
        ["页面", "支付"],
        g.rows.map(r => [r.link, r.paid])
    )
}
```

![[动画.gif]]
## 常见问题

在插件使用过程中或多或少会遇到些问题，下面我们搜集了一些常见问题供帮助读者排忧解难。

### 苹果系统中插入 HTML 代码中包含 `<img>` 标签并指定了本地图片，图片不显示问题。

下面是插入本地图片的一段常见代码，具有网页开发经验的读者觉得应该没毛病吧。

````
```dataviewjs
const attachments = this.app.vault.getConfig("attachmentFolderPath")
const basePath = this.app.vault.adapter.basePath
const image = "Pokémon-Icon_001.png"

const html = `
<img src="${basePath}/${attachments}/${image}" />
`

dv.el("div", html)
```
````

实际运行会发现图片并没有成功显示，控制台报 `net::ERR_FILE_NOT_FOUND` 错误。正确的使用姿势是在原有的路径上添加 `file:///` 前缀，即：`<img src="file://${basePath}/${attachments}/${image}" />`。

## 参考

- [Can't use HTML tag `<img>` to show local picture - Bug graveyard - Obsidian Forum](https://forum.obsidian.md/t/cant-use-html-tag-img-to-show-local-picture/34272)
- [Sorting groups in Dataview JS - Help - Obsidian Forum](https://forum.obsidian.md/t/sorting-groups-in-dataview-js/29126/4)